class y{constructor(){this.board=this.initializeBoard()}initializeBoard(){return[["bR","bN","bB","bQ","bK","bB","bN","bR"],["bP","bP","bP","bP","bP","bP","bP","bP"],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],["wP","wP","wP","wP","wP","wP","wP","wP"],["wR","wN","wB","wQ","wK","wB","wN","wR"]]}getPiece(e,t){return this.isValidSquare(e,t)?this.board[e][t]:null}setPiece(e,t,s){return this.isValidSquare(e,t)?(this.board[e][t]=s,!0):!1}isEmpty(e,t){return this.getPiece(e,t)===null}isValidSquare(e,t){return e>=0&&e<8&&t>=0&&t<8}getPieceColor(e,t){const s=this.getPiece(e,t);return s?s[0]:null}getPieceType(e,t){const s=this.getPiece(e,t);return s?s[1]:null}clone(){const e=new y;return e.board=this.board.map(t=>[...t]),e}clear(){this.board=Array(8).fill(null).map(()=>Array(8).fill(null))}findKing(e){for(let t=0;t<8;t++)for(let s=0;s<8;s++)if(this.getPiece(t,s)===`${e}K`)return{row:t,col:s};return null}}class P{static getPossibleMoves(e,t,s){const r=e.getPiece(t,s);if(!r)return[];const i=r[1],a=r[0];switch(i){case"P":return this.getPawnMoves(e,t,s,a);case"N":return this.getKnightMoves(e,t,s,a);case"B":return this.getBishopMoves(e,t,s,a);case"R":return this.getRookMoves(e,t,s,a);case"Q":return this.getQueenMoves(e,t,s,a);case"K":return this.getKingMoves(e,t,s,a);default:return[]}}static getPawnMoves(e,t,s,r){const i=[],a=r==="w"?-1:1,n=r==="w"?6:1,l=t+a;if(e.isEmpty(l,s)&&(i.push({row:l,col:s,type:"move"}),t===n)){const u=t+2*a;e.isEmpty(u,s)&&i.push({row:u,col:s,type:"move"})}for(const u of[-1,1]){const c=s+u;if(e.isValidSquare(l,c)){const o=e.getPiece(l,c);o&&o[0]!==r&&i.push({row:l,col:c,type:"capture"})}}return i}static getKnightMoves(e,t,s,r){const i=[],a=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];for(const[n,l]of a){const u=t+n,c=s+l;if(e.isValidSquare(u,c)){const o=e.getPiece(u,c);(!o||o[0]!==r)&&i.push({row:u,col:c,type:o?"capture":"move"})}}return i}static getBishopMoves(e,t,s,r){return this.getSlidingMoves(e,t,s,r,[[-1,-1],[-1,1],[1,-1],[1,1]])}static getRookMoves(e,t,s,r){return this.getSlidingMoves(e,t,s,r,[[-1,0],[1,0],[0,-1],[0,1]])}static getQueenMoves(e,t,s,r){return this.getSlidingMoves(e,t,s,r,[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]])}static getKingMoves(e,t,s,r){const i=[],a=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];for(const[l,u]of a){const c=t+l,o=s+u;if(e.isValidSquare(c,o)){const h=e.getPiece(c,o);(!h||h[0]!==r)&&i.push({row:c,col:o,type:h?"capture":"move"})}}const n=r==="w"?7:0;return t===n&&s===4&&(i.push({row:n,col:6,type:"castle-kingside"}),i.push({row:n,col:2,type:"castle-queenside"})),i}static getSlidingMoves(e,t,s,r,i){const a=[];for(const[n,l]of i){let u=t+n,c=s+l;for(;e.isValidSquare(u,c);){const o=e.getPiece(u,c);if(!o)a.push({row:u,col:c,type:"move"});else if(o[0]!==r){a.push({row:u,col:c,type:"capture"});break}else break;u+=n,c+=l}}return a}}class v{static isLegalMove(e,t,s,r,i,a){const n=e.getPiece(t,s);if(!n||n[0]!==a[0]||!e.isValidSquare(r,i)||!P.getPossibleMoves(e,t,s).some(h=>h.row===r&&h.col===i))return!1;const c=e.clone();return c.setPiece(r,i,n),c.setPiece(t,s,null),!this.isInCheck(c,a[0])}static isInCheck(e,t){const s=e.findKing(t);if(!s)return!1;const r=t==="w"?"b":"w";for(let i=0;i<8;i++)for(let a=0;a<8;a++){const n=e.getPiece(i,a);if(n&&n[0]===r&&P.getPossibleMoves(e,i,a).some(u=>u.row===s.row&&u.col===s.col))return!0}return!1}static isCheckmate(e,t){return this.isInCheck(e,t)?!this.hasLegalMoves(e,t):!1}static isStalemate(e,t){return this.isInCheck(e,t)?!1:!this.hasLegalMoves(e,t)}static hasLegalMoves(e,t){for(let s=0;s<8;s++)for(let r=0;r<8;r++){const i=e.getPiece(s,r);if(i&&i[0]===t){const a=P.getPossibleMoves(e,s,r);for(const n of a)if(this.isLegalMove(e,s,r,n.row,n.col,t))return!0}}return!1}static getLegalMoves(e,t,s,r){const i=e.getPiece(t,s);return!i||i[0]!==r[0]?[]:P.getPossibleMoves(e,t,s).filter(n=>this.isLegalMove(e,t,s,n.row,n.col,r))}}class w{static canCastle(e,t,s,r){const i=s==="w"?7:0,a=e.getPiece(i,4);if(!a||a!==`${s}K`||t.hasPieceMoved(i,4))return!1;if(r==="kingside"){const n=e.getPiece(i,7);return!(!n||n!==`${s}R`||t.hasPieceMoved(i,7)||!e.isEmpty(i,5)||!e.isEmpty(i,6)||this.isSquareAttacked(e,i,4,s)||this.isSquareAttacked(e,i,5,s)||this.isSquareAttacked(e,i,6,s))}else{const n=e.getPiece(i,0);return!(!n||n!==`${s}R`||t.hasPieceMoved(i,0)||!e.isEmpty(i,1)||!e.isEmpty(i,2)||!e.isEmpty(i,3)||this.isSquareAttacked(e,i,4,s)||this.isSquareAttacked(e,i,3,s)||this.isSquareAttacked(e,i,2,s))}}static executeCastle(e,t,s){const r=t==="w"?7:0;return s==="kingside"?(e.setPiece(r,6,`${t}K`),e.setPiece(r,4,null),e.setPiece(r,5,`${t}R`),e.setPiece(r,7,null),{type:"castle",side:"kingside",kingMove:{from:{row:r,col:4},to:{row:r,col:6}},rookMove:{from:{row:r,col:7},to:{row:r,col:5}}}):(e.setPiece(r,2,`${t}K`),e.setPiece(r,4,null),e.setPiece(r,3,`${t}R`),e.setPiece(r,0,null),{type:"castle",side:"queenside",kingMove:{from:{row:r,col:4},to:{row:r,col:2}},rookMove:{from:{row:r,col:0},to:{row:r,col:3}}})}static canEnPassant(e,t,s,r,i,a){const n=e.getPiece(s,r);if(!n||n[1]!=="P")return!1;const l=n[0];if(i!==s+(l==="w"?-1:1)||Math.abs(a-r)!==1||!e.isEmpty(i,a))return!1;const c=e.getPiece(s,a);if(!c||c[1]!=="P"||c[0]===l)return!1;const o=t.getLastMove();if(!o)return!1;const h=l==="w"?1:6,g=s;return!(o.to.row!==g||o.to.col!==a||o.from.row!==h||Math.abs(o.to.row-o.from.row)!==2)}static executeEnPassant(e,t,s,r,i){const a=e.getPiece(t,s);e.setPiece(r,i,a),e.setPiece(t,s,null);const n=e.getPiece(t,i);return e.setPiece(t,i,null),{type:"enpassant",capturedPawn:n,capturedAt:{row:t,col:i}}}static shouldPromote(e,t,s){const r=e.getPiece(t,s);if(!r||r[1]!=="P")return!1;const a=r[0]==="w"?0:7;return t===a}static executePromotion(e,t,s,r="Q"){const i=e.getPiece(t,s);if(!i)return!1;const n=`${i[0]}${r}`;return e.setPiece(t,s,n),{type:"promotion",from:i,to:n,position:{row:t,col:s}}}static isSquareAttacked(e,t,s,r){const i=r==="w"?"b":"w",n=t+(r==="w"?-1:1);for(const o of[-1,1]){const h=s+o;if(e.isValidSquare(n,h)&&e.getPiece(n,h)===`${i}P`)return!0}const l=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];for(const[o,h]of l){const g=t+o,m=s+h;if(e.isValidSquare(g,m)&&e.getPiece(g,m)===`${i}N`)return!0}for(let o=-1;o<=1;o++)for(let h=-1;h<=1;h++){if(o===0&&h===0)continue;const g=t+o,m=s+h;if(e.isValidSquare(g,m)&&e.getPiece(g,m)===`${i}K`)return!0}const u=[[-1,-1],[-1,1],[1,-1],[1,1]];for(const[o,h]of u){let g=t+o,m=s+h;for(;e.isValidSquare(g,m);){const p=e.getPiece(g,m);if(p){if(p[0]===i&&(p[1]==="B"||p[1]==="Q"))return!0;break}g+=o,m+=h}}const c=[[-1,0],[1,0],[0,-1],[0,1]];for(const[o,h]of c){let g=t+o,m=s+h;for(;e.isValidSquare(g,m);){const p=e.getPiece(g,m);if(p){if(p[0]===i&&(p[1]==="R"||p[1]==="Q"))return!0;break}g+=o,m+=h}}return!1}}class G{constructor(){this.board=new y,this.currentTurn="white",this.moveHistory=[],this.capturedPieces={white:[],black:[]},this.gameStatus="active",this.gameId=null,this.pieceMoveTracker=new Set,this.pendingPromotion=null}makeMove(e,t,s,r,i=null){if(this.pendingPromotion){if(!i)return"promotion";const h=w.executePromotion(this.board,this.pendingPromotion.row,this.pendingPromotion.col,i);return this.moveHistory[this.moveHistory.length-1].promotion=h,this.pendingPromotion=null,this.currentTurn=this.currentTurn==="white"?"black":"white",this.updateGameStatus(),!0}if(!v.isLegalMove(this.board,e,t,s,r,this.currentTurn)){const h=this.board.getPiece(e,t);if(h&&h[1]==="K"){const g=h[0];if(r===t+2&&w.canCastle(this.board,this,g,"kingside"))return this.executeCastling(g,"kingside");if(r===t-2&&w.canCastle(this.board,this,g,"queenside"))return this.executeCastling(g,"queenside")}return console.warn("Illegal move attempted:",{fromRow:e,fromCol:t,toRow:s,toCol:r}),!1}const n=this.board.getPiece(e,t),l=this.board.getPiece(s,r);let u=null;n[1]==="P"&&w.canEnPassant(this.board,this,e,t,s,r)?u=w.executeEnPassant(this.board,e,t,s,r):(this.board.setPiece(s,r,n),this.board.setPiece(e,t,null)),this.markPieceMoved(e,t);const c={from:{row:e,col:t},to:{row:s,col:r},piece:n,captured:u?u.capturedPawn:l,enPassant:u,timestamp:Date.now(),notation:this.moveToNotation(e,t,s,r,n,l||(u==null?void 0:u.capturedPawn))};this.moveHistory.push(c);const o=u?u.capturedPawn:l;if(o){const h=o[0]==="w"?"white":"black";this.capturedPieces[h].push(o)}return n[1]==="P"&&w.shouldPromote(this.board,s,r)?(this.pendingPromotion={row:s,col:r},"promotion"):(this.currentTurn=this.currentTurn==="white"?"black":"white",this.updateGameStatus(),!0)}executeCastling(e,t){const s=w.executeCastle(this.board,e,t);this.markPieceMoved(s.kingMove.from.row,s.kingMove.from.col),this.markPieceMoved(s.rookMove.from.row,s.rookMove.from.col);const r=t==="kingside"?"O-O":"O-O-O",i={from:s.kingMove.from,to:s.kingMove.to,piece:`${e}K`,captured:null,castle:s,timestamp:Date.now(),notation:r};return this.moveHistory.push(i),this.currentTurn=this.currentTurn==="white"?"black":"white",this.updateGameStatus(),!0}markPieceMoved(e,t){this.pieceMoveTracker.add(`${e},${t}`)}hasPieceMoved(e,t){return this.pieceMoveTracker.has(`${e},${t}`)}updateGameStatus(){const e=this.currentTurn[0];if(v.isCheckmate(this.board,e)){this.gameStatus="checkmate";const t=this.currentTurn==="white"?"Black":"White";console.log(`Checkmate! ${t} wins!`)}else v.isStalemate(this.board,e)?(this.gameStatus="stalemate",console.log("Stalemate! Game is a draw.")):v.isInCheck(this.board,e)?(this.gameStatus="check",console.log(`${this.currentTurn} is in check!`)):this.gameStatus="active"}moveToNotation(e,t,s,r,i,a){const n=i[1],l="abcdefgh",c=l[r]+"87654321"[s];return n==="P"?a?`${l[t]}x${c}`:c:a?`${n}x${c}`:`${n}${c}`}getLegalMoves(e,t){return v.getLegalMoves(this.board,e,t,this.currentTurn)}undoMove(){if(this.moveHistory.length===0)return!1;const e=this.moveHistory.pop();if(this.board.setPiece(e.from.row,e.from.col,e.piece),this.board.setPiece(e.to.row,e.to.col,e.captured),e.captured){const t=e.captured[0]==="w"?"white":"black";this.capturedPieces[t].pop()}return this.currentTurn=this.currentTurn==="white"?"black":"white",this.updateGameStatus(),!0}reset(){this.board=new y,this.currentTurn="white",this.moveHistory=[],this.capturedPieces={white:[],black:[]},this.gameStatus="active",this.pieceMoveTracker=new Set,this.pendingPromotion=null}getLastMove(){return this.moveHistory.length>0?this.moveHistory[this.moveHistory.length-1]:null}}class M{constructor(){this.gameState=new G}newGame(e=null){return this.gameState.reset(),e&&(this.gameState.gameId=e),this.gameState}makeMove(e,t,s,r){return this.gameState.makeMove(e,t,s,r)}getLegalMoves(e,t){return this.gameState.getLegalMoves(e,t)}undoMove(){return this.gameState.undoMove()}getBoard(){return this.gameState.board}getCurrentTurn(){return this.gameState.currentTurn}getGameStatus(){return this.gameState.gameStatus}getMoveHistory(){return this.gameState.moveHistory}getCapturedPieces(){return this.gameState.capturedPieces}getLastMove(){return this.gameState.getLastMove()}loadGameState(e){this.gameState=e}}class k{constructor(){this.games=new Map,this.defaultGame=null}register(e,t,s={}){if(this.games.has(e)){console.warn(`[GameRegistry] Game '${e}' is already registered`);return}if(!this.isValidGameEngine(t))throw new Error(`Game engine for '${e}' must extend BaseGameEngine`);const r={id:e,name:s.name||e,description:s.description||"",icon:s.icon||"🎮",category:s.category||"board",minPlayers:s.minPlayers||2,maxPlayers:s.maxPlayers||2,aiSupported:s.aiSupported||!1,difficultyLevels:s.difficultyLevels||[],GameEngine:t,metadata:s};this.games.set(e,r),console.log(`[GameRegistry] Registered game: ${e} (${r.name})`),(s.isDefault||this.games.size===1)&&(this.defaultGame=e)}unregister(e){this.games.delete(e)&&(console.log(`[GameRegistry] Unregistered game: ${e}`),this.defaultGame===e&&(this.defaultGame=this.games.size>0?this.games.keys().next().value:null))}getAllGames(){return Array.from(this.games.values())}getGameInfo(e){return this.games.get(e)||null}getDefaultGame(){return this.defaultGame}setDefaultGame(e){if(this.games.has(e))this.defaultGame=e,console.log(`[GameRegistry] Set default game to: ${e}`);else throw new Error(`Game '${e}' is not registered`)}createGameEngine(e){const t=this.games.get(e);if(!t)throw new Error(`Game '${e}' is not registered`);const s=t.GameEngine;return new s}getGamesByCategory(e){return this.getAllGames().filter(t=>t.category===e)}getAIGames(){return this.getAllGames().filter(e=>e.aiSupported)}isRegistered(e){return this.games.has(e)}getGameCount(){return this.games.size}isValidGameEngine(e){const t=["newGame","getBoard","getCurrentTurn","makeMove","getLegalMoves","getGameStatus","getMoveHistory","getCapturedPieces","undoMove","getGameName","getGameDescription","getBoardDimensions","getPieceTypes","getPlayerColors","getPieceAt","isValidPosition","getSquareColor","serialize","deserialize","encodeForURL","decodeFromURL"],s=e.prototype;return t.every(r=>typeof s[r]=="function")}getStats(){const e=this.getAllGames(),t=[...new Set(e.map(r=>r.category))],s=e.filter(r=>r.aiSupported);return{totalGames:e.length,categories:t.length,aiSupported:s.length,defaultGame:this.defaultGame,categories:t.sort()}}clear(){this.games.clear(),this.defaultGame=null,console.log("[GameRegistry] Cleared all games")}}const d=new k;typeof window<"u"&&(window.gameRegistry=d);class b{constructor(){if(this.constructor===b)throw new Error("BaseGameEngine is abstract and cannot be instantiated directly")}newGame(){throw new Error("newGame() must be implemented by subclass")}getBoard(){throw new Error("getBoard() must be implemented by subclass")}getCurrentTurn(){throw new Error("getCurrentTurn() must be implemented by subclass")}makeMove(e,t,s,r,i=null){throw new Error("makeMove() must be implemented by subclass")}getLegalMoves(e,t){throw new Error("getLegalMoves() must be implemented by subclass")}getGameStatus(){throw new Error("getGameStatus() must be implemented by subclass")}getMoveHistory(){throw new Error("getMoveHistory() must be implemented by subclass")}getCapturedPieces(){throw new Error("getCapturedPieces() must be implemented by subclass")}undoMove(){throw new Error("undoMove() must be implemented by subclass")}getGameName(){throw new Error("getGameName() must be implemented by subclass")}getGameDescription(){throw new Error("getGameDescription() must be implemented by subclass")}getBoardDimensions(){throw new Error("getBoardDimensions() must be implemented by subclass")}getPieceTypes(){throw new Error("getPieceTypes() must be implemented by subclass")}getPlayerColors(){throw new Error("getPlayerColors() must be implemented by subclass")}getPieceAt(e,t){throw new Error("getPieceAt() must be implemented by subclass")}isValidPosition(e,t){throw new Error("isValidPosition() must be implemented by subclass")}getSquareColor(e,t){throw new Error("getSquareColor() must be implemented by subclass")}async getAIMove(e,t){throw new Error("AI not supported for this game")}isAISupported(){return!1}serialize(){throw new Error("serialize() must be implemented by subclass")}deserialize(e){throw new Error("deserialize() must be implemented by subclass")}encodeForURL(){throw new Error("encodeForURL() must be implemented by subclass")}decodeFromURL(e){throw new Error("decodeFromURL() must be implemented by subclass")}getLastMove(){const e=this.getMoveHistory();return e.length>0?e[e.length-1]:null}isGameOver(){const e=this.getGameStatus();return e!=="playing"&&e!=="check"}getWinner(){return this.getGameStatus()==="checkmate"?this.getCurrentTurn()==="white"?"black":"white":null}getGameResult(){switch(this.getGameStatus()){case"checkmate":return this.getCurrentTurn()==="white"?"black-wins":"white-wins";case"stalemate":case"draw":return"draw";default:return"playing"}}}class S extends b{constructor(){super(),this.engine=new M}newGame(){return this.engine.newGame(),this.engine.getBoard()}getBoard(){return this.engine.getBoard()}getCurrentTurn(){return this.engine.getCurrentTurn()}makeMove(e,t,s,r,i=null){return this.engine.makeMove(e,t,s,r,i)}getLegalMoves(e,t){return this.engine.getLegalMoves(e,t)}getGameStatus(){return this.engine.getGameStatus()}getMoveHistory(){return this.engine.getMoveHistory()}getCapturedPieces(){return this.engine.getCapturedPieces()}undoMove(){return this.engine.undoMove()}getGameName(){return"Chess"}getGameDescription(){return"Classic strategy game with kings, queens, rooks, bishops, knights, and pawns"}getBoardDimensions(){return{rows:8,cols:8}}getPieceTypes(){return["K","Q","R","B","N","P"]}getPlayerColors(){return["white","black"]}getPieceAt(e,t){return this.getBoard().getPiece(e,t)}isValidPosition(e,t){return e>=0&&e<8&&t>=0&&t<8}getSquareColor(e,t){return(e+t)%2===0?"light":"dark"}async getAIMove(e,t){return null}isAISupported(){return!0}serialize(){return{gameType:"chess",board:this.engine.getBoard().serialize(),currentTurn:this.getCurrentTurn(),moveHistory:this.getMoveHistory(),capturedPieces:this.getCapturedPieces(),gameStatus:this.getGameStatus()}}deserialize(e){if(e.gameType!=="chess")throw new Error("Invalid game type for chess engine");this.engine.getBoard().deserialize(e.board),this.engine.gameState.currentTurn=e.currentTurn,this.engine.gameState.moveHistory=e.moveHistory,this.engine.gameState.capturedPieces=e.capturedPieces,this.engine.gameState.gameStatus=e.gameStatus}encodeForURL(){throw new Error("URL encoding not yet implemented in new architecture")}decodeFromURL(e){throw new Error("URL decoding not yet implemented in new architecture")}}class T extends b{constructor(){super(),this.board=null,this.currentTurn="red",this.moveHistory=[],this.capturedPieces={red:[],black:[]},this.gameStatus="playing",this.lastMove=null,this.newGame()}newGame(){this.board=Array(8).fill(null).map(()=>Array(8).fill(null));for(let e=0;e<3;e++)for(let t=0;t<8;t++)(e+t)%2===1&&(this.board[e][t]="red");for(let e=5;e<8;e++)for(let t=0;t<8;t++)(e+t)%2===1&&(this.board[e][t]="black");return this.currentTurn="red",this.moveHistory=[],this.capturedPieces={red:[],black:[]},this.gameStatus="playing",this.lastMove=null,this.getBoard()}getBoard(){return{getPiece:(e,t)=>this.board[e][t],setPiece:(e,t,s)=>{this.board[e][t]=s},serialize:()=>this.board.map(e=>[...e]),deserialize:e=>{this.board=e.map(t=>[...t])}}}getCurrentTurn(){return this.currentTurn}makeMove(e,t,s,r,i=null){if(!this.isValidMove(e,t,s,r))return!1;const a=this.getCapturedPiece(e,t,s,r),n=this.board[e][t];this.board[e][t]=null,this.board[s][r]=n,a&&this.capturedPieces[this.currentTurn].push(a),this.shouldPromoteToKing(s,r)&&(this.board[s][r]=this.currentTurn+"_king");const l={from:{row:e,col:t},to:{row:s,col:r},piece:n,captured:a,timestamp:Date.now()};return this.moveHistory.push(l),this.lastMove=l,a&&this.hasMoreCaptures(s,r)?(this.gameStatus="capturing","continue_capture"):(this.currentTurn=this.currentTurn==="red"?"black":"red",this.gameStatus="playing",this.checkWinCondition(),!0)}getLegalMoves(e,t){const s=this.board[e][t];if(!s||!s.startsWith(this.currentTurn))return[];const r=[],a=s.includes("king")?[[-1,-1],[-1,1],[1,-1],[1,1]]:this.currentTurn==="red"?[[1,-1],[1,1]]:[[-1,-1],[-1,1]];for(const[n,l]of a){const u=e+n,c=t+l;this.isValidPosition(u,c)&&this.board[u][c]===null&&r.push({row:u,col:c,type:"move"});const o=e+n*2,h=t+l*2,g=e+n,m=t+l;this.isValidPosition(o,h)&&this.board[o][h]===null&&this.board[g][m]!==null&&!this.board[g][m].startsWith(this.currentTurn)&&r.push({row:o,col:h,type:"capture",captured:{row:g,col:m}})}return r}getGameStatus(){return this.gameStatus}getMoveHistory(){return this.moveHistory}getCapturedPieces(){return this.capturedPieces}undoMove(){if(this.moveHistory.length===0)return!1;const e=this.moveHistory.pop(),{from:t,to:s,piece:r,captured:i}=e;return this.board[s.row][s.col]=null,this.board[t.row][t.col]=r,i&&(this.board[i.row][i.col]=i.piece,this.capturedPieces[this.currentTurn].pop()),this.currentTurn=this.currentTurn==="red"?"black":"red",this.gameStatus="playing",this.lastMove=this.moveHistory.length>0?this.moveHistory[this.moveHistory.length-1]:null,!0}getGameName(){return"Checkers"}getGameDescription(){return"Classic strategy game where pieces capture by jumping over opponents"}getBoardDimensions(){return{rows:8,cols:8}}getPieceTypes(){return["red","black","red_king","black_king"]}getPlayerColors(){return["red","black"]}getPieceAt(e,t){return this.board[e][t]}isValidPosition(e,t){return e>=0&&e<8&&t>=0&&t<8}getSquareColor(e,t){return(e+t)%2===0?"light":"dark"}async getAIMove(e,t){throw new Error("AI not yet implemented for checkers")}isAISupported(){return!0}serialize(){return{gameType:"checkers",board:this.board.map(e=>[...e]),currentTurn:this.currentTurn,moveHistory:this.moveHistory,capturedPieces:{...this.capturedPieces},gameStatus:this.gameStatus}}deserialize(e){if(e.gameType!=="checkers")throw new Error("Invalid game type for checkers engine");this.board=e.board.map(t=>[...t]),this.currentTurn=e.currentTurn,this.moveHistory=e.moveHistory,this.capturedPieces={...e.capturedPieces},this.gameStatus=e.gameStatus}encodeForURL(){throw new Error("URL encoding not yet implemented for checkers")}decodeFromURL(e){throw new Error("URL decoding not yet implemented for checkers")}isValidMove(e,t,s,r){const i=this.board[e][t];if(!i||!i.startsWith(this.currentTurn)||!this.isValidPosition(s,r)||this.board[s][r]!==null)return!1;const a=Math.abs(s-e),n=Math.abs(r-t);if(a!==n)return!1;if(!i.includes("king")){const u=this.currentTurn==="red"?1:-1;if((s-e)*u<=0)return!1}if(a===1)return!0;if(a===2){const u=e+(s-e)/2,c=t+(r-t)/2,o=this.board[u][c];return o!==null&&!o.startsWith(this.currentTurn)}return!1}getCapturedPiece(e,t,s,r){if(Math.abs(s-e)!==2)return null;const a=e+(s-e)/2,n=t+(r-t)/2,l=this.board[a][n];return l&&!l.startsWith(this.currentTurn)?(this.board[a][n]=null,l):null}shouldPromoteToKing(e,t){const s=this.board[e][t];return!s||s.includes("king")?!1:this.currentTurn==="red"&&e===7||this.currentTurn==="black"&&e===0}hasMoreCaptures(e,t){return this.getLegalMoves(e,t).some(r=>r.type==="capture")}checkWinCondition(){let e=!1;for(let s=0;s<8;s++){for(let r=0;r<8;r++)if(this.board[s][r]&&this.board[s][r].startsWith(this.currentTurn)){e=!0;break}if(e)break}if(!e){this.gameStatus="checkmate";return}let t=!1;for(let s=0;s<8;s++){for(let r=0;r<8;r++)if(this.board[s][r]&&this.board[s][r].startsWith(this.currentTurn)&&this.getLegalMoves(s,r).length>0){t=!0;break}if(t)break}t||(this.gameStatus="stalemate")}}class E{constructor(){this.currentGame=null,this.currentGameId=null,this.gameEngine=null,this.initializeGameRegistry(),this.loadGamePreference()}initializeGameRegistry(){d.register("chess",S,{name:"Chess",description:"Classic strategy game with kings, queens, rooks, bishops, knights, and pawns",icon:"♟️",category:"strategy",minPlayers:2,maxPlayers:2,aiSupported:!0,difficultyLevels:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],isDefault:!0}),d.register("checkers",T,{name:"Checkers",description:"Classic strategy game where pieces capture by jumping over opponents",icon:"🔴",category:"strategy",minPlayers:2,maxPlayers:2,aiSupported:!0,difficultyLevels:[1,2,3,4,5,6,7,8,9,10],isDefault:!1}),console.log("[MultiGameApp] Game registry initialized with",d.getGameCount(),"games")}loadGamePreference(){const e=localStorage.getItem("mate-current-game-type");e&&d.isRegistered(e)?this.currentGameId=e:this.currentGameId=d.getDefaultGame()}saveGamePreference(){this.currentGameId&&localStorage.setItem("mate-current-game-type",this.currentGameId)}getAvailableGames(){return d.getAllGames()}getCurrentGameInfo(){return d.getGameInfo(this.currentGameId)}switchGame(e){if(!d.isRegistered(e))return console.error(`[MultiGameApp] Game '${e}' is not registered`),!1;if(this.currentGameId===e)return console.log(`[MultiGameApp] Already playing ${e}`),!0;try{const t=d.createGameEngine(e);return this.currentGameId=e,this.gameEngine=t,this.saveGamePreference(),console.log(`[MultiGameApp] Switched to ${e}`),!0}catch(t){return console.error(`[MultiGameApp] Failed to switch to ${e}:`,t),!1}}getCurrentGameEngine(){if(!this.gameEngine&&this.currentGameId)try{this.gameEngine=d.createGameEngine(this.currentGameId)}catch(e){return console.error("[MultiGameApp] Failed to create game engine:",e),null}return this.gameEngine}startNewGame(e=null){if(e&&e!==this.currentGameId&&!this.switchGame(e))return!1;const t=this.getCurrentGameEngine();if(!t)return console.error("[MultiGameApp] No game engine available"),!1;try{return t.newGame(),console.log(`[MultiGameApp] Started new ${this.currentGameId} game`),!0}catch(s){return console.error("[MultiGameApp] Failed to start new game:",s),!1}}getGamesByCategory(e){return d.getGamesByCategory(e)}getAIGames(){return d.getAIGames()}currentGameSupportsAI(){const e=this.getCurrentGameEngine();return e?e.isAISupported():!1}getCurrentGameDifficultyLevels(){const e=this.getCurrentGameInfo();return e?e.difficultyLevels:[]}getStats(){return d.getStats()}getCurrentGameId(){return this.currentGameId}isGameAvailable(e){return d.isRegistered(e)}}typeof window<"u"&&(window.multiGameApp=new E);export{M as C,E as M};
